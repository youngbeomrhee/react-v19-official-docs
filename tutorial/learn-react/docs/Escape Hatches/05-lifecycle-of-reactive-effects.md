# Reactive Effect의 생명주기 요약 (한글 번역)

## 1. Effect의 생명주기
- React 컴포넌트는 mount → update → unmount 흐름을 가짐.
- 반면, `Effect`는 **동기화 시작(start)**과 **동기화 종료(stop)** 두 단계만 존재.
- props나 state가 바뀔 때마다 여러 번 동기화가 반복될 수 있음.

## 2. 컴포넌트 생명주기와 별도로 생각하라
- `Effect`는 외부 시스템(예: 채팅 서버)과의 동기화를 기술하는 역할.
- 컴포넌트의 상태나 props 변화에 따라 동기화 작업을 갱신해야 함.

## 3. 동기화 반복이 필요한 이유
- props (예: `roomId`)가 바뀌면, 이전 연결을 끊고 새 연결을 만들어야 함.
- 이를 위해 `Effect`는 body에서 연결 로직을, return에서 cleanup 로직을 명시.

## 4. React가 Effect를 다시 동기화하는 방식
- 의존성 배열에 명시된 값이 바뀌면, React는 cleanup 후 Effect를 다시 실행.
- 개발 모드에선 의도적으로 한 번 더 실행해 cleanup이 잘 구현되었는지 검증.

## 5. Effect는 별도 동기화 프로세스를 나타냄
- 여러 개의 동기화 대상이 있다면 `Effect`를 분리해 각각의 책임을 명확히 분리.
- 예: 서버 연결 로직과 analytics 로깅은 서로 다른 `Effect`로 작성.

## 6. 어떤 값이 의존성(dependency)이 되어야 하는가?
- 컴포넌트 내부에서 선언된 모든 변수는 "reactive"함.
- props, state, context, 내부 계산 변수는 모두 의존성 배열에 포함되어야 함.
- 전역 상수나 불변 값은 포함하지 않아도 됨.

## 7. 의존성을 생략하면 생기는 문제
- 의존성을 누락하면 `Effect`가 이전 값을 기준으로 동작하게 되어 버그 발생.
- React의 린터는 누락된 의존성을 자동으로 알려줌 (절대 무시하지 말 것!).

## 8. 재동기화를 원하지 않을 땐?
- 불변값은 컴포넌트 바깥에 선언하거나 `Effect` 내부에서 선언.
- 또는 "reactive"하지 않도록 렌더링 중 생성되는 객체/함수를 피함.

## ✅ 요약
- 컴포넌트는 마운트, 업데이트, 마운트 해제할 수 있습니다.
- 각 effect는 주변 컴포넌트와 별도의 생명주기를 가집니다.
- 각 effect는 시작 및 중지할 수 있는 별도의 동기화 프로세스를 설명합니다.
- effect를 작성하고 읽을 때는 컴포넌트의 관점(마운트, 업데이트 또는 마운트 해제 방법)이 아닌 개별 effect의 관점(동기화 시작 및 중지 방법)에서 생각하세요.
- 컴포넌트 본문 내부에 선언된 값은 “반응형”입니다.
- 반응형 값은 시간이 지남에 따라 변경될 수 있으므로 effect를 다시 동기화해야 합니다.
- 린터는 effect 내부에서 사용된 모든 반응형 값이 종속성으로 지정되었는지 확인합니다.
- 린터에 의해 플래그가 지정된 모든 오류는 합법적인 오류입니다. 규칙을 위반하지 않도록 코드를 수정할 방법은 항상 있습니다.
