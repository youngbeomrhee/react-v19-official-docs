# 📌 Preserving and Resetting State

React는 상태를 컴포넌트의 위치와 연결해서 관리해. 같은 위치에서 같은 컴포넌트를 렌더링하면 상태를 보존하고, 다른 컴포넌트로 바꾸거나 제거하면 상태를 초기화해.

---

## 🧠 상태는 트리 내 위치에 따라 결정됨

```jsx
<Counter />
<Counter />
```

- 두 개의 `<Counter />`는 트리 내 다른 위치에 있으므로 **독립적인 상태**를 가짐.
- 컴포넌트는 **렌더 트리 상의 위치**가 동일할 때만 상태를 유지함.
- JSX 상에서 동일해 보여도, 트리 위치가 다르면 상태도 다름.

---

## 🔁 상태가 보존되는 조건

```jsx
{isFancy ? <Counter isFancy={true} /> : <Counter isFancy={false} />}
```

- 조건부 렌더링이 있어도 JSX 트리 상 **같은 위치**에서 `<Counter />`가 렌더링되면 상태는 **유지**됨.
- 상태는 JSX 코드 구조가 아니라 **실제 렌더 트리 위치**에 따라 달라져.

---

## ❌ 상태가 초기화되는 조건

### 다른 컴포넌트로 대체될 때

```jsx
{isPaused ? <p>Paused</p> : <Counter />}
```

- 같은 위치에 `<p>` → `<Counter>`로 교체되면 상태 **초기화**됨.

### 다른 부모 엘리먼트일 경우

```jsx
{isFancy
  ? <div><Counter /></div>
  : <section><Counter /></section>}
```

- 부모 요소가 달라지면 하위 트리 전체가 교체되므로 `<Counter />`의 상태도 **초기화**됨.

---

## 🧱 key를 통한 상태 제어

```jsx
{isPlayerA
  ? <Counter key="A" person="A" />
  : <Counter key="B" person="B" />}
```

- 서로 다른 key 값을 주면 React는 완전히 **다른 컴포넌트로 인식**해서 상태를 초기화함.
- 특히 채팅이나 입력 폼에서 이전 입력을 **리셋**하려면 유용해.

---

## ☝️ 예외: JSX 안에서 함수 컴포넌트를 정의하지 말 것

```jsx
function MyComponent() {
  function MyInput() {
    const [text, setText] = useState('');
    return <input value={text} onChange={e => setText(e.target.value)} />;
  }

  return <MyInput />;
}
```

- 렌더할 때마다 새로운 컴포넌트가 생성되기 때문에 상태가 **매번 초기화**됨.
- **항상 최상단에서 함수형 컴포넌트를 정의**해야 함.

---

## 🧪 상태 보존/초기화의 요약

| 조건                                          | 상태 유지 여부 |
|-----------------------------------------------|----------------|
| 같은 컴포넌트, 같은 위치                       | ✅ 유지됨       |
| 다른 컴포넌트로 교체                           | ❌ 초기화       |
| key가 다름                                     | ❌ 초기화       |
| 부모 트리 구조가 변경됨                       | ❌ 초기화       |
| 컴포넌트를 중첩된 함수로 정의                 | ❌ 초기화       |

---

## 💬 실전 팁

- **폼 리셋이 필요**할 때 `<Component key={someId} />` 패턴 활용
- 렌더 트리 구조가 계속 유지되도록 **조건부 렌더링 구조를 안정적으로 설계**
- **같은 key = 같은 상태**, **다른 key = 새로운 상태**
